<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFS Attractor Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Geist+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        /* --- 1. Global & Layout Styling (EFIELD-Inspired) --- */
        :root {
            --bg-body: #fdfdfd;
            --bg-panel: #f8f8f8;
            --text-primary: #222;
            --text-secondary: #444;
            --accent-red: #9a2b17;
            /* EFIELD button/thumb color */
            --border-color: #ccc;
            --spacing: 12px;
            --radius: 6px;
            --canvas-margin: 20px;
        }

        body {
            font-family: 'Geist Mono', monospace;
            display: flex;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-body);
            color: var(--text-primary);
        }

        /* --- 2. Control Panel & Scrollbar Styling --- */
        #controls {
            width: 350px;
            flex-shrink: 0;
            background: var(--bg-panel);
            padding: var(--spacing);
            border-right: 1px solid var(--border-color);
            overflow-y: scroll;
            display: flex;
            flex-direction: column;
        }

        /* Custom Scrollbar Styling for Webkit (Chrome, Safari) */
        #controls::-webkit-scrollbar {
            width: 8px;
        }

        #controls::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        #controls::-webkit-scrollbar-thumb {
            background-color: #d0d0d0;
            /* Light grey */
            border-radius: 4px;
            border: 2px solid var(--bg-panel);
        }

        /* Remove up/down handles (buttons) */
        #controls::-webkit-scrollbar-button {
            display: none;
        }

        #controls::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-red);
        }

        /* Custom Scrollbar Styling for Firefox */
        #controls {
            scrollbar-width: thin;
            scrollbar-color: #d0d0d0 var(--bg-panel);
        }


        #controls h2 {
            color: var(--accent-red);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: var(--spacing);
            font-size: 1.4em;
            font-weight: bold;
        }

        /* Fieldset/Legend Styling (Unchanged) */
        fieldset {
            margin-bottom: var(--spacing);
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
        }

        legend {
            font-weight: bold;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        /* --- 3. Canvas Area & Toggleable Canvas Mode (Updated) --- */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: var(--canvas-margin);
        }

        #outputCanvas {
            display: block;
            background: #000;
            border: none;
            /* Dark mode: no border */
            border-radius: var(--radius);
        }

        /* Light Canvas Mode */
        body.light-canvas-mode #outputCanvas {
            background: #fff;
            /* Thicker border for light mode */
            border: 3px solid #777;
        }

        /* --- 4. Inputs and Buttons --- */
        button {
            font-family: 'Geist Mono', monospace;
            border: none;
            padding: 6px 10px;
            background: var(--accent-red);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s;
            margin-bottom: 6px;
            font-weight: 500;
        }

        button:hover {
            opacity: 0.8;
        }

        input[type="number"],
        input[type="range"],
        select {
            font-family: 'Geist Mono', monospace;
            background: transparent;
            border: none;
            border-bottom: 3px solid #888;
            padding: 3px 4px;
            outline: none;
            width: 60px;
            color: var(--text-primary);
            transition: all 0.2s;
        }

        input:focus,
        input:hover {
            border-bottom-color: var(--accent-red);
        }

        /* Color Selector Styling */
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            padding: 0;
            width: 60px;
            height: 20px;
            cursor: pointer;
            background-color: transparent;
            border-radius: var(--radius);
            vertical-align: middle;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: var(--radius);
            width: 60px;
            height: 20px;
        }

        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: var(--radius);
            width: 60px;
            height: 20px;
        }


        select {
            width: 100%;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            box-sizing: border-box;
            margin-bottom: 5px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 12px;
            border-radius: 6px;
            background: #ddd;
            cursor: pointer;
            margin-left: 4px;
            vertical-align: middle;
            border: none;
        }

        input[type="range"]::-webkit-slider-thumb,
        input[type="range"]::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-red);
            cursor: pointer;
            border: none;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 6px;
        }

        .action-buttons button {
            flex-grow: 1;
        }

        /* A row with three buttons needs all to be smaller */
        .action-buttons.three-col button {
            flex-grow: 1;
            min-width: 0;
            /* Allow the button to shrink */
        }

        #playPauseBtn {
            background-color: #555;
        }

        #playPauseBtn.playing {
            background-color: var(--accent-red);
        }

        #playPauseBtn:hover {
            background-color: #666;
        }

        /* Icon styling */
        .material-icons-round {
            font-size: 18px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* --- 5. Transform List Styling --- */
        #transformationsList {
            margin-bottom: var(--spacing);
        }

        .transform-item {
            border: 1px solid var(--border-color);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: var(--radius);
            background: var(--bg-body);
            cursor: pointer;
            transition: border-color 0.2s, padding 0.2s;
        }

        .transform-item h4 {
            margin: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1em;
        }

        /* Dark red bold outline for selected item */
        .transform-item.selected {
            border: 2px solid var(--accent-red);
            background: var(--bg-body);
            padding: 9px;
        }

        .transform-params {
            display: none;
            padding-top: 10px;
            margin-top: 10px;
            border-top: 1px dashed var(--border-color);
        }

        .transform-item.selected .transform-params {
            display: block;
        }

        .flex-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .range-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
            flex-basis: calc(50% - 5px);
        }

        .range-label span {
            color: var(--accent-red);
        }

        /* --- 6. Visual Editor Handles --- */
        .transform-overlay {
            position: absolute;
            box-sizing: border-box;
            cursor: grab;
            touch-action: none;
            transform-origin: 0 0;
            /* CRITICAL FIX: Hint to use GPU for better anti-aliasing on rotation */
            will-change: transform;
            border: none;
            box-shadow: none !important;
            /* Ensure no residual shadow/blur */
        }

        /* Unselected state: Use a crisp 1px border. Rely on will-change for smoothing. */
        .transform-overlay:not(.selected) {
            border: 1px solid currentColor;
        }

        .transform-overlay.selected {
            z-index: 100;
            /* When selected, JS sets a 2px border */
        }

        /* Base handle style */
        .handle {
            position: absolute;
            touch-action: none;
            z-index: 101;
            cursor: grab;
            box-shadow: none;
            border: none;
        }

        /* Corner Handle - Smaller, solid circle, perfectly centered, color set by JS */
        .handle.corner {
            width: 10px;
            height: 10px;
            background: var(--accent-red);
            /* Base color, overwritten by JS */
            border-radius: 50%;
            margin: -5px;
        }

        /* Rotation Handle - Only the large icon, no background */
        .handle.rotate {
            background: none;
            width: 28px;
            height: 28px;
            margin-left: -14px;
            margin-top: -34px;
            left: 50%;
            cursor: grab;

            /* Styles to center the icon */
            display: flex;
            align-items: center;
            justify-content: center;
            /* Color set by JS */
            padding: 0;
            font-size: 28px;
        }

        .handle.rotate .material-icons-round {
            margin: 0;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h2>IFS Attractor Generator</h2>

        <fieldset>
            <legend>Iteration Parameters</legend>
            <div class="flex-row" style="margin-bottom: 10px;">
                <label>Points: <input type="number" id="numIterations" value="20000" min="1000"
                        onchange="saveSettings()"></label>
                <label>Alpha: <input type="number" id="alphaValue" value="0.05" min="0.01" max="1.0" step="0.01"
                        onchange="saveSettings()"></label>
            </div>

            <div class="action-buttons">
                <button id="iterateBtn">
                    <span class="material-icons-round">play_arrow</span>
                    Run Step
                </button>
                <button id="playPauseBtn">
                    <span class="material-icons-round">play_circle</span>
                    Auto-Iterate
                </button>
            </div>

            <div class="action-buttons three-col">
                <button id="canvasModeToggleBtn" style="background-color: #5b5b5b;">
                    <span class="material-icons-round">light_mode</span>
                    Light Canvas
                </button>
                <button id="bnwToggleBtn" style="background-color: #5b5b5b;">
                    <span class="material-icons-round">invert_colors</span>
                    B&W Transforms
                </button>
                <button id="toggleRectsBtn" style="background-color: #5b5b5b;">
                    <span class="material-icons-round">visibility_off</span>
                    Hide Transforms
                </button>
            </div>

            <div class="action-buttons">
                <button id="randomBtn">
                    <span class="material-icons-round">casino</span>
                    Randomize All
                </button>
                <button id="resetBtn">
                    <span class="material-icons-round">delete_sweep</span>
                    Clear Canvas
                </button>
            </div>
            <div class="action-buttons">
                <button id="resetSettingsBtn" style="background-color: #555; width: 100%;">
                    <span class="material-icons-round">settings_backup_restore</span>
                    Reset All Settings
                </button>
            </div>
        </fieldset>
        <fieldset id="presets">
            <legend>Load Preset IFS</legend>
            <select id="presetSelect">
                <option value="none">-- Select a Fractal --</option>
                <option value="barnsley">Barnsley Fern</option>
                <option value="sierpinski">Sierpinski Gasket</option>
                <option value="dragon">Dragon Curve</option>
                <option value="koch">Koch Variant</option>
                <option value="cantor">Cantor Dust</option>
            </select>
            <button onclick="loadPreset()" style="background-color: #5b5b5b; width: 100%; margin-top: 5px;">
                <span class="material-icons-round">folder_open</span>
                Load Preset
            </button>
        </fieldset>

        <fieldset id="transformsFieldset">
            <legend>Transformations (Maps)</legend>
            <div id="transformationsList">
            </div>
            <button id="addTransform">
                <span class="material-icons-round">add</span>
                Add New Transform
            </button>
        </fieldset>
    </div>

    <div id="canvas-container">
        <canvas id="outputCanvas"></canvas>
    </div>

    <script>
        // --- 1. Global Variables & Initialization ---
        let CANVAS_SIZE = 0;
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d');
        const transformationsList = document.getElementById('transformationsList');
        const canvasContainer = document.getElementById('canvas-container');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const canvasModeToggleBtn = document.getElementById('canvasModeToggleBtn');
        const bnwToggleBtn = document.getElementById('bnwToggleBtn');
        const toggleRectsBtn = document.getElementById('toggleRectsBtn'); // NEW
        const resetSettingsBtn = document.getElementById('resetSettingsBtn');

        let transformationRects = [];
        let activeRectIndex = -1;
        let intervalId = null;
        let isCanvasLightMode = false;
        let isBNWTransformMode = false;
        let showTransforms = true; // NEW STATE

        let dragMode = null;
        let dragStartX, dragStartY;
        let initialRectState;

        const LOCAL_STORAGE_KEY = 'ifsAttractorSettings';

        // COLOR CONSTANTS
        const ACCENT_RED = '#9a2b17';
        const WHITE_COLOR = '#fff';

        const IFS_PRESETS = {
            barnsley: [
                { x: 295, y: 504, width: 10, height: 96, rotation: 0.0, p: 0.01, color: '#32CD32' },
                { x: 45, y: 285, width: 510, height: 510, rotation: 0.03, p: 0.85, color: '#228B22' },
                { x: 200, y: 200, width: 150, height: 150, rotation: 0.85, p: 0.07, color: '#3CB371' },
                { x: 250, y: 350, width: 150, height: 150, rotation: -0.85, p: 0.07, color: '#00FA9A' }
            ],
            sierpinski: [
                { x: 0, y: 0, width: 300, height: 300, rotation: 0, p: 0.333, color: '#FFD700' },
                { x: 300, y: 0, width: 300, height: 300, rotation: 0, p: 0.333, color: '#1E90FF' },
                { x: 150, y: 300, width: 300, height: 300, rotation: 0, p: 0.334, color: '#FF4500' }
            ],
            koch: [
                { x: 0, y: 400, width: 200, height: 200, rotation: 0, p: 0.25, color: '#e0b0ff' },
                { x: 200, y: 400, width: 200, height: 200, rotation: Math.PI / 3, p: 0.25, color: '#dda0dd' },
                { x: 300, y: 227, width: 200, height: 200, rotation: -Math.PI / 3, p: 0.25, color: '#ffb6c1' },
                { x: 400, y: 400, width: 200, height: 200, rotation: 0, p: 0.25, color: '#ffc0cb' }
            ],
            cantor: [
                { x: 0, y: 200, width: 200, height: 100, rotation: 0, p: 0.5, color: '#FFFFFF' },
                { x: 400, y: 200, width: 200, height: 100, rotation: 0, p: 0.5, color: '#FFFFFF' }
            ],
            dragon: [
                { x: 100, y: 200, width: 400, height: 400, rotation: -Math.PI / 4, p: 0.5, color: '#4682B4' },
                { x: 200, y: 100, width: 400, height: 400, rotation: 3 * Math.PI / 4, p: 0.5, color: '#87CEFA' }
            ]
        };


        // --- 2. Core Fractal Functions ---

        function getAffineMatrixFromRect(rect) {
            const scaleX = rect.width / CANVAS_SIZE;
            const scaleY = rect.height / CANVAS_SIZE;
            const cosRot = Math.cos(rect.rotation);
            const sinRot = Math.sin(rect.rotation);

            const A = scaleX * cosRot;
            const B = -scaleY * sinRot;
            const C = scaleX * sinRot;
            const D = scaleY * cosRot;

            const rectCenterX = rect.x + rect.width / 2;
            const rectCenterY = rect.y + rect.height / 2;

            const normRectCenterX = (rectCenterX - CANVAS_SIZE / 2) / (CANVAS_SIZE / 4);
            const normRectCenterY = (rectCenterY - CANVAS_SIZE / 2) / (CANVAS_SIZE / 4);

            const E = normRectCenterX;
            const F = normRectCenterY;

            return { a: A, b: B, c: C, d: D, e: E, f: F };
        }

        function applyIFSMapping(transform, x, y) {
            const { a, b, c, d, e, f } = transform;
            return {
                x: a * x + b * y + e,
                y: c * x + d * y + f
            };
        }

        function runIFS(numPoints) {
            let currentX = 0;
            let currentY = 0;
            const newPoints = [];
            const BURN_IN = 20;

            if (transformationRects.length === 0) return [];

            // NEW: Determine attractor color override
            const bnwAttractorColor = isBNWTransformMode ? (isCanvasLightMode ? ACCENT_RED : WHITE_COLOR) : null;

            const mappings = transformationRects.map(rect => ({
                matrix: getAffineMatrixFromRect(rect),
                p: rect.p,
                color: rect.color
            }));

            let totalProb = mappings.reduce((sum, m) => sum + m.p, 0);
            if (totalProb === 0) return [];

            const cumulativeProbs = [];
            let currentSum = 0;
            for (let m of mappings) {
                currentSum += m.p / totalProb;
                cumulativeProbs.push(currentSum);
            }

            for (let i = 0; i < numPoints + BURN_IN; i++) {
                const r = Math.random();
                let selectedMapping = null;
                for (let j = 0; j < mappings.length; j++) {
                    if (r < cumulativeProbs[j]) {
                        selectedMapping = mappings[j];
                        break;
                    }
                }
                if (!selectedMapping) selectedMapping = mappings[0];

                const nextPoint = applyIFSMapping(selectedMapping.matrix, currentX, currentY);
                currentX = nextPoint.x;
                currentY = nextPoint.y;

                if (i >= BURN_IN) {
                    const pointColor = bnwAttractorColor || selectedMapping.color; // Use B&W color if active
                    newPoints.push({ x: currentX, y: currentY, color: pointColor });
                }
            }
            return newPoints;
        }

        function mapToCanvas(coord) {
            const scale = CANVAS_SIZE / 4;
            const offset = CANVAS_SIZE / 2;
            return coord * scale + offset;
        }

        function drawPoints(newPoints, alpha) {
            ctx.globalAlpha = alpha;
            newPoints.forEach(point => {
                const px = mapToCanvas(point.x);
                const py = mapToCanvas(point.y);
                ctx.fillStyle = point.color;
                ctx.fillRect(px, py, 1, 1);
            });
            ctx.globalAlpha = 1.0;
        }

        // --- 3. UI and Control Functions (Local Storage Integration) ---

        function runSingleIteration() {
            if (transformationRects.length === 0) return;
            resetCanvas(true);
            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);
            drawPoints(runIFS(numIter), alpha);
            document.getElementById('iterateBtn').setAttribute('data-ran-once', 'true');
        }

        function saveSettings() {
            const scaleFactor = 600 / CANVAS_SIZE;
            const scaledRects = transformationRects.map(rect => ({
                ...rect,
                x: rect.x * scaleFactor,
                y: rect.y * scaleFactor,
                width: rect.width * scaleFactor,
                height: rect.height * scaleFactor
            }));

            const settings = {
                numIterations: document.getElementById('numIterations').value,
                alphaValue: document.getElementById('alphaValue').value,
                isCanvasLightMode: isCanvasLightMode,
                isBNWTransformMode: isBNWTransformMode,
                showTransforms: showTransforms, // SAVE NEW STATE
                transformationRects: scaledRects
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(settings));
        }

        function loadSettings() {
            const savedSettings = localStorage.getItem(LOCAL_STORAGE_KEY);
            const initialScaleFactor = CANVAS_SIZE / 600;

            if (savedSettings) {
                const settings = JSON.parse(savedSettings);

                // 1. Load Iteration Parameters
                document.getElementById('numIterations').value = settings.numIterations;
                document.getElementById('alphaValue').value = settings.alphaValue;

                // 2. Load Visual Modes
                isCanvasLightMode = settings.isCanvasLightMode;
                document.body.classList.toggle('light-canvas-mode', isCanvasLightMode);
                canvasModeToggleBtn.innerHTML = isCanvasLightMode
                    ? '<span class="material-icons-round">dark_mode</span>Dark Canvas'
                    : '<span class="material-icons-round">light_mode</span>Light Canvas';

                isBNWTransformMode = settings.isBNWTransformMode || false;
                bnwToggleBtn.innerHTML = isBNWTransformMode
                    ? '<span class="material-icons-round">palette</span>Colored Transforms'
                    : '<span class="material-icons-round">invert_colors</span>B&W Transforms';

                showTransforms = settings.showTransforms !== undefined ? settings.showTransforms : true; // LOAD NEW STATE
                toggleRectsBtn.innerHTML = showTransforms
                    ? '<span class="material-icons-round">visibility_off</span>Hide Transforms'
                    : '<span class="material-icons-round">visibility</span>Show Transforms';


                // 3. Load Transformations
                transformationRects = settings.transformationRects.map(rect => {
                    return {
                        ...rect,
                        x: rect.x * initialScaleFactor,
                        y: rect.y * initialScaleFactor,
                        width: rect.width * initialScaleFactor,
                        height: rect.height * initialScaleFactor,
                        rotation: rect.rotation,
                        p: rect.p,
                        color: rect.color
                    };
                });
            } else {
                // Load default Sierpinski Gasket if no saved settings
                isCanvasLightMode = false;
                document.body.classList.remove('light-canvas-mode');
                isBNWTransformMode = false;
                showTransforms = true;

                IFS_PRESETS.sierpinski.forEach(rect => {
                    transformationRects.push({
                        x: rect.x * initialScaleFactor,
                        y: rect.y * initialScaleFactor,
                        width: rect.width * initialScaleFactor,
                        height: rect.height * initialScaleFactor,
                        rotation: rect.rotation,
                        p: rect.p,
                        color: rect.color
                    });
                });
            }

            resetCanvas(true);
            renderTransformationsUI();
            setActiveTransform(0);

            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);
            drawPoints(runIFS(numIter), alpha);
        }

        function resetAllSettings() {
            if (!confirm("Are you sure you want to reset all settings and clear local storage?")) {
                return;
            }
            stopAutoIterate();
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            transformationRects = [];
            activeRectIndex = -1;
            setCanvasSize();
            loadSettings();
            alert("All settings have been reset to default (Sierpinski Gasket).");
        }

        function stopAutoIterate() {
            clearInterval(intervalId);
            intervalId = null;
            playPauseBtn.innerHTML = '<span class="material-icons-round">play_circle</span>Auto-Iterate';
            playPauseBtn.classList.remove('playing');
        }

        function startAutoIterate() {
            if (transformationRects.length === 0) {
                alert("Add or load a transformation set first.");
                return;
            }
            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);

            resetCanvas(true);

            const iterateStep = () => {
                const newPoints = runIFS(numIter);
                drawPoints(newPoints, alpha);
                document.getElementById('iterateBtn').setAttribute('data-ran-once', 'true');
            };

            iterateStep();
            intervalId = setInterval(iterateStep, 100);
            playPauseBtn.innerHTML = '<span class="material-icons-round">pause_circle</span>Pause Auto-Iterate';
            playPauseBtn.classList.add('playing');
        }

        function toggleAutoIterate() {
            if (intervalId) {
                stopAutoIterate();
            } else {
                startAutoIterate();
            }
        }

        function resetCanvas(clearOnly = true) {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.fillStyle = isCanvasLightMode ? '#fff' : '#000';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }

        function updateVisualModes() {
            // Re-run the fractal drawing if necessary when visual modes change
            if (intervalId) {
                stopAutoIterate();
                startAutoIterate();
            } else if (document.getElementById('iterateBtn').hasAttribute('data-ran-once')) {
                runSingleIteration();
            }
        }

        function toggleCanvasTheme() {
            isCanvasLightMode = !isCanvasLightMode;
            document.body.classList.toggle('light-canvas-mode', isCanvasLightMode);

            canvasModeToggleBtn.innerHTML = isCanvasLightMode
                ? '<span class="material-icons-round">dark_mode</span>Dark Canvas'
                : '<span class="material-icons-round">light_mode</span>Light Canvas';

            resetCanvas(true);
            drawOverlays();
            updateVisualModes();
            saveSettings();
        }

        function toggleBNWTransforms() {
            isBNWTransformMode = !isBNWTransformMode;

            bnwToggleBtn.innerHTML = isBNWTransformMode
                ? '<span class="material-icons-round">palette</span>Colored Transforms'
                : '<span class="material-icons-round">invert_colors</span>B&W Transforms';

            drawOverlays();
            updateVisualModes();
            saveSettings();
        }

        // NEW FUNCTION
        function toggleShowTransforms() {
            showTransforms = !showTransforms;
            toggleRectsBtn.innerHTML = showTransforms
                ? '<span class="material-icons-round">visibility_off</span>Hide Transforms'
                : '<span class="material-icons-round">visibility</span>Show Transforms';

            drawOverlays();
            saveSettings();
        }

        function setActiveTransform(index) {
            activeRectIndex = index;
            renderTransformationsUI();
        }

        function updateTransformRect(index, key, value) {
            const val = (key === 'color') ? value : parseFloat(value);
            if (isNaN(val) && key !== 'color') return;
            transformationRects[index][key] = val;

            if (intervalId && key !== 'color' && key !== 'p') {
                resetCanvas(true);
            }

            if (key === 'width' || key === 'height') {
                renderTransformationsUI();
            } else {
                drawOverlays();
                const item = document.querySelector(`.transform-item[data-index="${index}"]`);
                if (item) {
                    if (item.querySelector(`input[name="${key}"][type="range"]`)) {
                        const span = item.querySelector(`input[name="${key}"]`).closest('.range-label').querySelector('span');
                        if (span) {
                            span.textContent = key === 'rotation' ? `${(val * 180 / Math.PI).toFixed(1)}°` : `${Math.round(val)}`;
                        }
                    }
                    if (key === 'color') {
                        if (!isBNWTransformMode) {
                            const h4Span = item.querySelector('h4 span');
                            if (h4Span) h4Span.style.color = val;
                        }
                    }
                    if (key === 'p') {
                        const h4Span = item.querySelector('h4 span');
                        if (h4Span) h4Span.textContent = `(P=${(val).toFixed(3)})`;
                    }
                }
            }
            saveSettings();
        }

        function removeTransformRect(index) {
            transformationRects.splice(index, 1);
            activeRectIndex = -1;
            if (intervalId) {
                resetCanvas(true);
            }
            renderTransformationsUI();
            saveSettings();
        }

        function addTransformUI(initialData = null) {
            const newRect = initialData || {
                x: CANVAS_SIZE * 0.25, y: CANVAS_SIZE * 0.25, width: CANVAS_SIZE * 0.5, height: CANVAS_SIZE * 0.5, rotation: 0, p: 1 / (transformationRects.length + 1 || 1),
                color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`
            };
            transformationRects.push(newRect);
            if (intervalId) {
                resetCanvas(true);
            }
            renderTransformationsUI();
            setActiveTransform(transformationRects.length - 1);
            saveSettings();
        }

        function renderTransformationsUI() {
            transformationsList.innerHTML = '';
            transformationRects.forEach((rect, index) => {
                const div = document.createElement('div');
                div.className = 'transform-item';
                div.dataset.index = index;
                div.classList.toggle('selected', index === activeRectIndex);
                div.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT' && e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {
                        setActiveTransform(index);
                    }
                };

                const labelColor = isBNWTransformMode ? 'var(--text-secondary)' : rect.color;

                const maxRangeX = CANVAS_SIZE - 10;
                const maxRangeY = CANVAS_SIZE - 10;
                const currentRotDeg = (rect.rotation * 180 / Math.PI).toFixed(1);

                div.innerHTML = `
                    <h4>
                        Map ${index + 1} <span style="color:${labelColor}; font-weight:400;">(P=${(rect.p).toFixed(3)})</span>
                        <button onclick="event.stopPropagation(); removeTransformRect(${index})"
                                style="background-color: #555; width: 30px; height: 30px; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                            <span class="material-icons-round" style="font-size:18px; margin: 0;">close</span>
                        </button>
                    </h4>
                    <div class="transform-params">
                        <div class="flex-row">
                            <label>P (Weight): <input type="number" step="0.01" value="${rect.p}" onchange="updateTransformRect(${index}, 'p', this.value)" style="width: 50px;"></label>
                        </div>
                        <div class="flex-row" style="margin-top: 8px;">
                            <label>Color: <input type="color" value="${rect.color}" onchange="updateTransformRect(${index}, 'color', this.value)"></label>
                        </div>
                        <div class="flex-row">
                            <label class="range-label">X: <input type="range" name="x" min="${-CANVAS_SIZE}" max="${maxRangeX}" value="${rect.x}" oninput="updateTransformRect(${index}, 'x', this.value)" style="width: 80px;"> <span>${Math.round(rect.x)}</span></label>
                            <label class="range-label">Y: <input type="range" name="y" min="${-CANVAS_SIZE}" max="${maxRangeY}" value="${rect.y}" oninput="updateTransformRect(${index}, 'y', this.value)" style="width: 80px;"> <span>${Math.round(rect.y)}</span></label>
                        </div>
                        <div class="flex-row">
                            <label class="range-label">W: <input type="range" name="width" min="10" max="${CANVAS_SIZE}" value="${rect.width}" oninput="updateTransformRect(${index}, 'width', this.value)" style="width: 80px;"> <span>${Math.round(rect.width)}</span></label>
                            <label class="range-label">H: <input type="range" name="height" min="10" max="${CANVAS_SIZE}" value="${rect.height}" oninput="updateTransformRect(${index}, 'height', this.value)" style="width: 80px;"> <span>${Math.round(rect.height)}</span></label>
                        </div>
                        <div class="flex-row">
                            <label class="range-label">Rot: <input type="range" name="rotation" min="-3.141" max="3.141" step="0.001" value="${rect.rotation}" oninput="updateTransformRect(${index}, 'rotation', this.value)" style="width: 80px;"> <span>${currentRotDeg}°</span></label>
                        </div>
                    </div>
                `;
                transformationsList.appendChild(div);
            });
            drawOverlays();
        }

        function setCanvasSize() {
            stopAutoIterate();

            const containerRect = canvasContainer.getBoundingClientRect();
            const style = getComputedStyle(canvasContainer);
            const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);

            const availableWidth = containerRect.width - paddingX;
            const availableHeight = containerRect.height - paddingY;
            const size = Math.floor(Math.min(availableWidth, availableHeight));

            const isInitialLoad = CANVAS_SIZE === 0;

            if (canvas.width !== size && CANVAS_SIZE > 0) {
                const scaleFactor = size / CANVAS_SIZE;

                transformationRects.forEach(rect => {
                    rect.x *= scaleFactor;
                    rect.y *= scaleFactor;
                    rect.width *= scaleFactor;
                    rect.height *= scaleFactor;
                });
            }

            CANVAS_SIZE = size;
            canvas.width = size;
            canvas.height = size;

            if (!isInitialLoad) {
                resetCanvas(true);
            }

            renderTransformationsUI();
        }

        function generateRandomIFS(count) {
            for (let i = 0; i < count; i++) {
                const randomRect = {
                    x: Math.random() * (CANVAS_SIZE * 0.5) + (CANVAS_SIZE * 0.1),
                    y: Math.random() * (CANVAS_SIZE * 0.5) + (CANVAS_SIZE * 0.1),
                    width: Math.random() * (CANVAS_SIZE * 0.3) + (CANVAS_SIZE * 0.05),
                    height: Math.random() * (CANVAS_SIZE * 0.3) + (CANVAS_SIZE * 0.05),
                    rotation: Math.random() * 2 * Math.PI,
                    p: 1 / count,
                    color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`
                };
                transformationRects.push(randomRect);
            }
        }

        function loadPreset() {
            const presetKey = document.getElementById('presetSelect').value;
            if (presetKey === 'none') return;

            stopAutoIterate();
            transformationRects = [];
            activeRectIndex = -1;

            const presetData = IFS_PRESETS[presetKey];
            const scaleFactor = CANVAS_SIZE / 600;

            presetData.forEach(rect => {
                transformationRects.push({
                    x: rect.x * scaleFactor,
                    y: rect.y * scaleFactor,
                    width: rect.width * scaleFactor,
                    height: rect.height * scaleFactor,
                    rotation: rect.rotation,
                    p: rect.p,
                    color: rect.color
                });
            });

            renderTransformationsUI();
            runSingleIteration(); // Re-run the fractal
            saveSettings();
        }

        // --- 4. Visual Editor (Overlay Logic) ---

        function drawOverlays() {
            document.querySelectorAll('.transform-overlay').forEach(el => el.remove());

            if (!showTransforms) { // CHECK NEW STATE
                return;
            }

            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = canvasContainer.getBoundingClientRect();

            const canvasLeftOffset = canvasRect.left - containerRect.left;
            const canvasTopOffset = canvasRect.top - containerRect.top;

            transformationRects.forEach((rect, index) => {

                // DYNAMIC COLOR CALCULATION
                const currentTransformColor = (function () {
                    if (!isBNWTransformMode) {
                        return rect.color;
                    }
                    if (isCanvasLightMode) {
                        return ACCENT_RED;
                    }
                    return WHITE_COLOR;
                })();


                const overlay = document.createElement('div');
                overlay.className = 'transform-overlay';
                overlay.dataset.index = index;

                overlay.style.color = currentTransformColor;

                const roundedWidth = Math.round(rect.width);
                const roundedHeight = Math.round(rect.height);
                const roundedX = Math.round(rect.x);
                const roundedY = Math.round(rect.y);

                overlay.style.width = `${roundedWidth}px`;
                overlay.style.height = `${roundedHeight}px`;

                overlay.style.left = `${canvasLeftOffset + roundedX}px`;
                overlay.style.top = `${canvasTopOffset + roundedY}px`;
                overlay.style.transform = `rotate(${rect.rotation}rad)`;

                if (index === activeRectIndex) {
                    overlay.classList.add('selected');
                    overlay.style.border = `2px solid ${currentTransformColor}`;

                    const handles = [
                        { class: 'corner tl', x: 0, y: 0 },
                        { class: 'corner tr', x: roundedWidth, y: 0 },
                        { class: 'corner bl', x: 0, y: roundedHeight },
                        { class: 'corner br', x: roundedWidth, y: roundedHeight }
                    ];

                    handles.forEach(h => {
                        const handle = document.createElement('div');
                        handle.className = `handle ${h.class}`;
                        handle.style.left = `${h.x}px`;
                        handle.style.top = `${h.y}px`;
                        handle.style.backgroundColor = currentTransformColor;
                        overlay.appendChild(handle);
                    });

                    const rotateHandle = document.createElement('div');
                    rotateHandle.className = 'handle rotate';
                    rotateHandle.innerHTML = '<span class="material-icons-round">rotate_right</span>';
                    rotateHandle.style.color = currentTransformColor;
                    overlay.appendChild(rotateHandle);
                } else {
                    overlay.style.border = '';
                }

                canvasContainer.appendChild(overlay);
            });
        }


        // --- 5. Initialisation and Event Handlers ---

        function initialize() {
            setCanvasSize();
            loadSettings();
        }

        // Mouse/Touch Interaction for Overlays
        canvasContainer.addEventListener('pointerdown', (e) => {
            const target = e.target;
            const overlay = target.closest('.transform-overlay');

            const canvasRect = canvas.getBoundingClientRect();

            if (overlay && showTransforms) { // CHECK NEW STATE
                e.preventDefault();
                const index = parseInt(overlay.dataset.index);
                setActiveTransform(index);

                activeRect = { ...transformationRects[index], index: index };

                dragStartX = e.clientX - canvasRect.left;
                dragStartY = e.clientY - canvasRect.top;
                initialRectState = { ...activeRect };

                if (target.classList.contains('handle') || target.closest('.handle')) {
                    if (target.classList.contains('rotate') || target.closest('.rotate')) { dragMode = 'rotate'; }
                    else if (target.classList.contains('br')) { dragMode = 'resize-br'; }
                    else if (target.classList.contains('tl')) { dragMode = 'resize-tl'; }
                    else if (target.classList.contains('tr')) { dragMode = 'resize-tr'; }
                    else if (target.classList.contains('bl')) { dragMode = 'resize-bl'; }
                } else {
                    dragMode = 'move';
                }
            } else {
                setActiveTransform(-1);
            }
        });

        canvasContainer.addEventListener('pointermove', (e) => {
            if (activeRectIndex === -1 || !dragMode) return;
            // ... (pointermove logic remains the same) ...
            e.preventDefault();
            const canvasRect = canvas.getBoundingClientRect();

            const currentX = e.clientX - canvasRect.left;
            const currentY = e.clientY - canvasRect.top;

            const dx = currentX - dragStartX;
            const dy = currentY - dragStartY;

            const rect = transformationRects[activeRectIndex];

            switch (dragMode) {
                case 'move':
                    rect.x = initialRectState.x + dx;
                    rect.y = initialRectState.y + dy;
                    break;
                case 'resize-br':
                    rect.width = initialRectState.width + dx;
                    rect.height = initialRectState.height + dy;
                    break;
                case 'resize-tl':
                    rect.x = initialRectState.x + dx;
                    rect.y = initialRectState.y + dy;
                    rect.width = initialRectState.width - dx;
                    rect.height = initialRectState.height - dy;
                    break;
                case 'resize-tr':
                    rect.y = initialRectState.y + dy;
                    rect.width = initialRectState.width + dx;
                    rect.height = initialRectState.height - dy;
                    break;
                case 'resize-bl':
                    rect.x = initialRectState.x + dx;
                    rect.width = initialRectState.width - dx;
                    rect.height = initialRectState.height + dy;
                    break;
                case 'rotate':
                    const rectCenterX = initialRectState.x + initialRectState.width / 2;
                    const rectCenterY = initialRectState.y + initialRectState.height / 2;
                    const initialAngle = Math.atan2(dragStartY - rectCenterY, dragStartX - rectCenterX);
                    const currentAngle = Math.atan2(currentY - rectCenterY, currentX - rectCenterX);
                    rect.rotation = initialRectState.rotation + (currentAngle - initialAngle);
                    break;
            }

            rect.width = Math.max(10, rect.width);
            rect.height = Math.max(10, rect.height);
            rect.x = Math.max(-rect.width + 10, Math.min(rect.x, CANVAS_SIZE - 10));
            rect.y = Math.max(-rect.height + 10, Math.min(rect.y, CANVAS_SIZE - 10));

            if (intervalId) {
                resetCanvas(true);
            }

            renderTransformationsUI();
        });

        canvasContainer.addEventListener('pointerup', () => {
            if (dragMode) {
                saveSettings();
            }
            dragMode = null;
            renderTransformationsUI();
        });

        // Control Panel Event Listeners
        document.getElementById('addTransform').addEventListener('click', () => {
            stopAutoIterate();
            addTransformUI();
        });

        document.getElementById('iterateBtn').addEventListener('click', () => {
            stopAutoIterate();
            if (transformationRects.length === 0) {
                alert("Please add or load a transformation set.");
                return;
            }
            runSingleIteration();
        });

        document.getElementById('playPauseBtn').addEventListener('click', toggleAutoIterate);
        document.getElementById('canvasModeToggleBtn').addEventListener('click', toggleCanvasTheme);
        document.getElementById('bnwToggleBtn').addEventListener('click', toggleBNWTransforms);
        document.getElementById('toggleRectsBtn').addEventListener('click', toggleShowTransforms); // NEW LISTENER

        document.getElementById('randomBtn').addEventListener('click', () => {
            stopAutoIterate();
            transformationRects = [];
            generateRandomIFS(Math.floor(Math.random() * 4) + 2);
            renderTransformationsUI();
            runSingleIteration();
            saveSettings();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            stopAutoIterate();
            resetCanvas(true);
        });

        resetSettingsBtn.addEventListener('click', resetAllSettings);

        window.addEventListener('resize', setCanvasSize);

        initialize();
    </script>

</body>

</html>