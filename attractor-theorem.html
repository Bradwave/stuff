<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFS Attractor Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Geist+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        /* --- 1. Global & Layout Styling (EFIELD-Inspired) --- */
        :root {
            --bg-body: #fdfdfd;
            --bg-panel: #f8f8f8;
            --text-primary: #222;
            --text-secondary: #444;
            --accent-red: #9a2b17;
            /* EFIELD button/thumb color */
            --border-color: #ccc;
            --spacing: 12px;
            --radius: 6px;
            --canvas-margin: 20px;
        }

        body {
            font-family: 'Geist Mono', monospace;
            display: flex;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-body);
            color: var(--text-primary);
        }

        /* --- 2. Control Panel --- */
        #controls {
            width: 350px;
            flex-shrink: 0;
            background: var(--bg-panel);
            padding: var(--spacing);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #controls h2 {
            color: var(--accent-red);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: var(--spacing);
            font-size: 1.4em;
            font-weight: bold;
        }

        /* Fieldset/Legend Styling */
        fieldset {
            margin-bottom: var(--spacing);
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
        }

        legend {
            font-weight: bold;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        /* --- 3. Canvas Area & Toggleable Canvas Mode --- */
        #canvas-container {
            flex-grow: 1;
            /* Ensures canvas takes up max horizontal space */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: var(--canvas-margin);
        }

        #outputCanvas {
            display: block;
            background: #000;
            /* Default Dark Mode */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
        }

        /* Light Canvas Mode */
        body.light-canvas-mode #outputCanvas {
            background: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
        }

        /* --- 4. Inputs and Buttons --- */
        button {
            font-family: 'Geist Mono', monospace;
            border: none;
            padding: 6px 10px;
            background: var(--accent-red);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s;
            margin-bottom: 6px;
            font-weight: 500;
        }

        button:hover {
            opacity: 0.8;
        }

        input[type="number"],
        input[type="range"],
        select {
            font-family: 'Geist Mono', monospace;
            background: transparent;
            border: none;
            border-bottom: 3px solid #888;
            padding: 3px 4px;
            outline: none;
            width: 60px;
            color: var(--text-primary);
            transition: all 0.2s;
        }

        input:focus,
        input:hover {
            border-bottom-color: var(--accent-red);
        }

        select {
            width: 100%;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            box-sizing: border-box;
            margin-bottom: 5px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 12px;
            border-radius: 6px;
            background: #ddd;
            cursor: pointer;
            margin-left: 4px;
            vertical-align: middle;
            border: none;
        }

        input[type="range"]::-webkit-slider-thumb,
        input[type="range"]::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-red);
            cursor: pointer;
            border: none;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 6px;
        }

        .action-buttons button {
            flex-grow: 1;
        }

        #playPauseBtn {
            background-color: #555;
        }

        #playPauseBtn.playing {
            background-color: var(--accent-red);
        }

        #playPauseBtn:hover {
            background-color: #666;
        }

        /* Icon styling */
        .material-icons-round {
            font-size: 18px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* --- 5. Transform List Styling --- */
        #transformationsList {
            margin-bottom: var(--spacing);
        }

        .transform-item {
            border: 1px solid var(--border-color);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: var(--radius);
            background: var(--bg-body);
            cursor: pointer;
            transition: border-color 0.2s, padding 0.2s;
        }

        .transform-item h4 {
            margin: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1em;
        }

        /* Dark red bold outline for selected item */
        .transform-item.selected {
            border: 2px solid var(--accent-red);
            background: var(--bg-body);
            padding: 9px;
        }

        .transform-params {
            display: none;
            padding-top: 10px;
            margin-top: 10px;
            border-top: 1px dashed var(--border-color);
        }

        .transform-item.selected .transform-params {
            display: block;
        }

        .flex-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .range-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
            flex-basis: calc(50% - 5px);
        }

        .range-label span {
            color: var(--accent-red);
        }

        /* --- 6. Visual Editor Handles --- */
        .transform-overlay {
            position: absolute;
            box-sizing: border-box;
            cursor: grab;
            touch-action: none;
            transform-origin: 0 0;
            border: none;
        }

        .transform-overlay.selected {
            z-index: 100;
        }

        /* Default Handle (Corner: Hollow Red Circle for Resize) */
        .handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid var(--accent-red);
            /* Hollow appearance */
            border-radius: 50%;
            touch-action: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            margin: -6px;
            z-index: 101;
        }

        /* Cursors to indicate corner functionality */
        .handle.tl {
            cursor: nwse-resize;
        }

        .handle.tr {
            cursor: nesw-resize;
        }

        .handle.bl {
            cursor: nesw-resize;
        }

        .handle.br {
            cursor: nwse-resize;
        }

        /* Rotation Handle (Filled Red Circle, outside the rectangle) */
        .handle.rotate {
            background: var(--accent-red);
            cursor: grab;
            top: -30px;
            left: 50%;
            margin: -6px 0 0 -6px;
            border: none;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h2>IFS Attractor Generator</h2>

        <fieldset>
            <legend>Iteration Parameters</legend>
            <div class="flex-row" style="margin-bottom: 10px;">
                <label>Points: <input type="number" id="numIterations" value="20000" min="1000"></label>
                <label>Alpha: <input type="number" id="alphaValue" value="0.05" min="0.01" max="1.0"
                        step="0.01"></label>
            </div>

            <div class="action-buttons">
                <button id="iterateBtn">
                    <span class="material-icons-round">play_arrow</span>
                    Run Step
                </button>
                <button id="playPauseBtn">
                    <span class="material-icons-round">play_circle</span>
                    Auto-Iterate
                </button>
            </div>
            <div class="action-buttons">
                <button id="canvasModeToggleBtn" style="background-color: #5b5b5b;">
                    <span class="material-icons-round">light_mode</span>
                    Light Canvas
                </button>
            </div>
            <div class="action-buttons">
                <button id="randomBtn">
                    <span class="material-icons-round">casino</span>
                    Randomize All
                </button>
                <button id="resetBtn">
                    <span class="material-icons-round">delete_sweep</span>
                    Clear Canvas
                </button>
            </div>
        </fieldset>
        <fieldset id="presets">
            <legend>Load Preset IFS</legend>
            <select id="presetSelect">
                <option value="none">-- Select a Fractal --</option>
                <option value="barnsley">Barnsley Fern</option>
                <option value="sierpinski">Sierpinski Gasket</option>
                <option value="dragon">Dragon Curve</option>
                <option value="koch">Koch Variant</option>
                <option value="cantor">Cantor Dust</option>
            </select>
            <button onclick="loadPreset()" style="background-color: #5b5b5b; width: 100%; margin-top: 5px;">
                <span class="material-icons-round">folder_open</span>
                Load Preset
            </button>
        </fieldset>

        <fieldset id="transformsFieldset">
            <legend>Transformations (Maps)</legend>
            <div id="transformationsList">
            </div>
            <button id="addTransform">
                <span class="material-icons-round">add</span>
                Add New Transform
            </button>
        </fieldset>
    </div>

    <div id="canvas-container">
        <canvas id="outputCanvas"></canvas>
    </div>

    <script>
        // --- 1. Global Variables & Initialization ---
        let CANVAS_SIZE = 600;
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d');
        const transformationsList = document.getElementById('transformationsList');
        const canvasContainer = document.getElementById('canvas-container');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const canvasModeToggleBtn = document.getElementById('canvasModeToggleBtn');

        let transformationRects = [];
        let activeRectIndex = -1;
        let intervalId = null;
        let isCanvasLightMode = false;

        let dragMode = null;
        let dragStartX, dragStartY;
        let initialRectState;

        const IFS_PRESETS = {
            barnsley: [
                { x: 295, y: 0, width: 15, height: 96, rotation: 0.0, p: 0.01, color: '#32CD32' },
                { x: 100, y: 96, width: 490, height: 490, rotation: -0.05, p: 0.85, color: '#228B22' },
                { x: 100, y: 96, width: 220, height: 220, rotation: 0.4, p: 0.07, color: '#3CB371' },
                { x: 380, y: 250, width: 200, height: 200, rotation: -0.4, p: 0.07, color: '#00FA9A' }
            ],
            sierpinski: [
                { x: 0, y: 0, width: 300, height: 300, rotation: 0, p: 0.333, color: '#FFD700' },
                { x: 300, y: 0, width: 300, height: 300, rotation: 0, p: 0.333, color: '#1E90FF' },
                { x: 150, y: 300, width: 300, height: 300, rotation: 0, p: 0.334, color: '#FF4500' }
            ],
            koch: [
                { x: 0, y: 0, width: 200, height: 200, rotation: 0, p: 0.25, color: '#e0b0ff' },
                { x: 200, y: 0, width: 200, height: 200, rotation: Math.PI / 3, p: 0.25, color: '#dda0dd' },
                { x: 300, y: 173, width: 200, height: 200, rotation: -Math.PI / 3, p: 0.25, color: '#ffb6c1' },
                { x: 400, y: 0, width: 200, height: 200, rotation: 0, p: 0.25, color: '#ffc0cb' }
            ],
            cantor: [
                { x: 0, y: 200, width: 200, height: 100, rotation: 0, p: 0.5, color: '#FFFFFF' },
                { x: 400, y: 200, width: 200, height: 100, rotation: 0, p: 0.5, color: '#FFFFFF' }
            ],
            dragon: [
                { x: 0, y: 0, width: 300, height: 300, rotation: -Math.PI / 4, p: 0.5, color: '#4682B4' },
                { x: 300, y: 300, width: 300, height: 300, rotation: 3 * Math.PI / 4, p: 0.5, color: '#87CEFA' }
            ]
        };

        // --- 2. Core Fractal Functions ---

        function getAffineMatrixFromRect(rect) {
            const scaleX = rect.width / CANVAS_SIZE;
            const scaleY = rect.height / CANVAS_SIZE;
            const cosRot = Math.cos(rect.rotation);
            const sinRot = Math.sin(rect.rotation);

            const A = scaleX * cosRot;
            const B = -scaleY * sinRot;
            const C = scaleX * sinRot;
            const D = scaleY * cosRot;

            const normRectCenterX = (rect.x + rect.width / 2 - CANVAS_SIZE / 2) / (CANVAS_SIZE / 4);
            const normRectCenterY = (rect.y + rect.height / 2 - CANVAS_SIZE / 2) / (CANVAS_SIZE / 4);

            const E = normRectCenterX;
            const F = normRectCenterY;

            return { a: A, b: B, c: C, d: D, e: E, f: F };
        }

        function applyIFSMapping(transform, x, y) {
            const { a, b, c, d, e, f } = transform;
            return {
                x: a * x + b * y + e,
                y: c * x + d * y + f
            };
        }

        function runIFS(numPoints) {
            let currentX = 0;
            let currentY = 0;
            const newPoints = [];
            const BURN_IN = 20;

            if (transformationRects.length === 0) return [];

            const mappings = transformationRects.map(rect => ({
                matrix: getAffineMatrixFromRect(rect),
                p: rect.p,
                color: rect.color
            }));

            let totalProb = mappings.reduce((sum, m) => sum + m.p, 0);
            if (totalProb === 0) return [];

            const cumulativeProbs = [];
            let currentSum = 0;
            for (let m of mappings) {
                currentSum += m.p / totalProb;
                cumulativeProbs.push(currentSum);
            }

            for (let i = 0; i < numPoints + BURN_IN; i++) {
                const r = Math.random();
                let selectedMapping = null;
                for (let j = 0; j < mappings.length; j++) {
                    if (r < cumulativeProbs[j]) {
                        selectedMapping = mappings[j];
                        break;
                    }
                }
                if (!selectedMapping) selectedMapping = mappings[0];

                const nextPoint = applyIFSMapping(selectedMapping.matrix, currentX, currentY);
                currentX = nextPoint.x;
                currentY = nextPoint.y;

                if (i >= BURN_IN) {
                    newPoints.push({ x: currentX, y: currentY, color: selectedMapping.color });
                }
            }
            return newPoints;
        }

        function mapToCanvas(coord) {
            const scale = CANVAS_SIZE / 4;
            const offset = CANVAS_SIZE / 2;
            return coord * scale + offset;
        }

        function drawPoints(newPoints, alpha) {
            ctx.globalAlpha = alpha;
            newPoints.forEach(point => {
                const px = mapToCanvas(point.x);
                const py = mapToCanvas(point.y);
                ctx.fillStyle = point.color;
                ctx.fillRect(px, py, 1, 1);
            });
            ctx.globalAlpha = 1.0;
        }

        // --- 3. UI and Control Functions ---

        function stopAutoIterate() {
            clearInterval(intervalId);
            intervalId = null;
            playPauseBtn.innerHTML = '<span class="material-icons-round">play_circle</span>Auto-Iterate';
            playPauseBtn.classList.remove('playing');
        }

        function startAutoIterate() {
            if (transformationRects.length === 0) {
                alert("Add or load a transformation set first.");
                return;
            }
            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);

            const iterateStep = () => {
                const newPoints = runIFS(numIter);
                drawPoints(newPoints, alpha);
            };

            iterateStep();
            intervalId = setInterval(iterateStep, 100);
            playPauseBtn.innerHTML = '<span class="material-icons-round">pause_circle</span>Pause Auto-Iterate';
            playPauseBtn.classList.add('playing');
        }

        // FIX: Defined function for event listener
        function toggleAutoIterate() {
            if (intervalId) {
                stopAutoIterate();
            } else {
                startAutoIterate();
            }
        }

        function resetCanvas(clearOnly = true) {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.fillStyle = isCanvasLightMode ? '#fff' : '#000';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }

        function toggleCanvasTheme() {
            isCanvasLightMode = !isCanvasLightMode;
            document.body.classList.toggle('light-canvas-mode', isCanvasLightMode);

            canvasModeToggleBtn.innerHTML = isCanvasLightMode
                ? '<span class="material-icons-round">dark_mode</span>Dark Canvas'
                : '<span class="material-icons-round">light_mode</span>Light Canvas';

            resetCanvas(true);
        }

        function setActiveTransform(index) {
            activeRectIndex = index;
            renderTransformationsUI();
        }

        function updateTransformRect(index, key, value) {
            const val = (key === 'color') ? value : parseFloat(value);
            if (isNaN(val) && key !== 'color') return;
            transformationRects[index][key] = val;

            if (key === 'width' || key === 'height') {
                renderTransformationsUI();
            } else {
                drawOverlays();
                const item = document.querySelector(`.transform-item[data-index="${index}"]`);
                if (item && item.querySelector(`input[name="${key}"][type="range"]`)) {
                    const span = item.querySelector(`input[name="${key}"]`).closest('.range-label').querySelector('span');
                    if (span) {
                        span.textContent = key === 'rotation' ? `${(val * 180 / Math.PI).toFixed(1)}°` : `${Math.round(val)}`;
                    }
                }
            }
        }

        function removeTransformRect(index) {
            transformationRects.splice(index, 1);
            activeRectIndex = -1;
            renderTransformationsUI();
        }

        // FIX: Defined function for event listener
        function addTransformUI(initialData = null) {
            const newRect = initialData || {
                x: CANVAS_SIZE * 0.25, y: CANVAS_SIZE * 0.25, width: CANVAS_SIZE * 0.5, height: CANVAS_SIZE * 0.5, rotation: 0, p: 1 / (transformationRects.length + 1 || 1),
                color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`
            };
            transformationRects.push(newRect);
            renderTransformationsUI();
            setActiveTransform(transformationRects.length - 1);
        }

        function renderTransformationsUI() {
            transformationsList.innerHTML = '';
            transformationRects.forEach((rect, index) => {
                const div = document.createElement('div');
                div.className = 'transform-item';
                div.dataset.index = index;
                div.classList.toggle('selected', index === activeRectIndex);
                div.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT' && e.target.tagName !== 'BUTTON') {
                        setActiveTransform(index);
                    }
                };

                const maxRangeX = CANVAS_SIZE - rect.width;
                const maxRangeY = CANVAS_SIZE - rect.height;
                const currentRotDeg = (rect.rotation * 180 / Math.PI).toFixed(1);

                div.innerHTML = `
                    <h4>
                        Map ${index + 1} <span style="color:${rect.color}; font-weight:400;">(P=${(rect.p).toFixed(3)})</span>
                        <button onclick="event.stopPropagation(); removeTransformRect(${index})" 
                                style="background-color: #555; padding: 5px 10px; font-size: 0.8em;">
                            <span class="material-icons-round" style="font-size:1em;">close</span>
                        </button>
                    </h4>
                    <div class="transform-params">
                        <div class="flex-row">
                            <label>P (Weight): <input type="number" step="0.01" value="${rect.p}" onchange="updateTransformRect(${index}, 'p', this.value)" style="width: 50px;"></label>
                            <label>Color: <input type="color" value="${rect.color}" onchange="updateTransformRect(${index}, 'color', this.value)" style="width: 50px;"></label>
                        </div>
                        <div class="flex-row">
                            <label class="range-label">X: <input type="range" name="x" min="0" max="${maxRangeX}" value="${rect.x}" oninput="updateTransformRect(${index}, 'x', this.value)" style="width: 80px;"> <span>${Math.round(rect.x)}</span></label>
                            <label class="range-label">Y: <input type="range" name="y" min="0" max="${maxRangeY}" value="${rect.y}" oninput="updateTransformRect(${index}, 'y', this.value)" style="width: 80px;"> <span>${Math.round(rect.y)}</span></label>
                        </div>
                        <div class="flex-row">
                            <label class="range-label">W: <input type="range" name="width" min="10" max="${CANVAS_SIZE}" value="${rect.width}" oninput="updateTransformRect(${index}, 'width', this.value)" style="width: 80px;"> <span>${Math.round(rect.width)}</span></label>
                            <label class="range-label">H: <input type="range" name="height" min="10" max="${CANVAS_SIZE}" value="${rect.height}" oninput="updateTransformRect(${index}, 'height', this.value)" style="width: 80px;"> <span>${Math.round(rect.height)}</span></label>
                        </div>
                        <div class="flex-row">
                            <label class="range-label">Rot: <input type="range" name="rotation" min="-3.141" max="3.141" step="0.001" value="${rect.rotation}" oninput="updateTransformRect(${index}, 'rotation', this.value)" style="width: 80px;"> <span>${currentRotDeg}°</span></label>
                        </div>
                    </div>
                `;
                transformationsList.appendChild(div);
            });
            drawOverlays();
        }

        function setCanvasSize() {
            stopAutoIterate();

            const containerRect = canvasContainer.getBoundingClientRect();
            const style = getComputedStyle(canvasContainer);
            const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);

            const availableWidth = containerRect.width - paddingX;
            const availableHeight = containerRect.height - paddingY;
            const size = Math.floor(Math.min(availableWidth, availableHeight));

            if (canvas.width !== size && CANVAS_SIZE > 0) {
                const scaleFactor = size / CANVAS_SIZE;

                transformationRects.forEach(rect => {
                    rect.x *= scaleFactor;
                    rect.y *= scaleFactor;
                    rect.width *= scaleFactor;
                    rect.height *= scaleFactor;
                });
            }

            CANVAS_SIZE = size;
            canvas.width = size;
            canvas.height = size;

            resetCanvas(true);
            renderTransformationsUI();
        }

        function generateRandomIFS(count) {
            for (let i = 0; i < count; i++) {
                const randomRect = {
                    x: Math.random() * (CANVAS_SIZE * 0.5) + (CANVAS_SIZE * 0.1),
                    y: Math.random() * (CANVAS_SIZE * 0.5) + (CANVAS_SIZE * 0.1),
                    width: Math.random() * (CANVAS_SIZE * 0.3) + (CANVAS_SIZE * 0.05),
                    height: Math.random() * (CANVAS_SIZE * 0.3) + (CANVAS_SIZE * 0.05),
                    rotation: Math.random() * 2 * Math.PI,
                    p: 1 / count,
                    color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`
                };
                transformationRects.push(randomRect);
            }
        }

        function loadPreset() {
            const presetKey = document.getElementById('presetSelect').value;
            if (presetKey === 'none') return;

            stopAutoIterate();
            transformationRects = [];
            activeRectIndex = -1;

            const presetData = IFS_PRESETS[presetKey];
            const scaleFactor = CANVAS_SIZE / 600;

            presetData.forEach(rect => {
                transformationRects.push({
                    x: rect.x * scaleFactor,
                    y: rect.y * scaleFactor,
                    width: rect.width * scaleFactor,
                    height: rect.height * scaleFactor,
                    rotation: rect.rotation,
                    p: rect.p,
                    color: rect.color
                });
            });

            renderTransformationsUI();
            resetCanvas();
            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);
            drawPoints(runIFS(numIter), alpha);
        }

        // --- 4. Visual Editor (Overlay Logic) ---

        function drawOverlays() {
            document.querySelectorAll('.transform-overlay').forEach(el => el.remove());

            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = canvasContainer.getBoundingClientRect();

            const canvasLeftOffset = canvasRect.left - containerRect.left;
            const canvasTopOffset = canvasRect.top - containerRect.top;

            transformationRects.forEach((rect, index) => {
                const overlay = document.createElement('div');
                overlay.className = 'transform-overlay';
                overlay.dataset.index = index;

                overlay.style.width = `${rect.width}px`;
                overlay.style.height = `${rect.height}px`;

                overlay.style.left = `${canvasLeftOffset + rect.x}px`;
                overlay.style.top = `${canvasTopOffset + rect.y}px`;
                overlay.style.transform = `rotate(${rect.rotation}rad)`;

                // Solid border with transformation color
                const borderWidth = (index === activeRectIndex) ? '2px' : '1px';
                overlay.style.border = `${borderWidth} solid ${rect.color}`;


                if (index === activeRectIndex) {
                    overlay.classList.add('selected');

                    const handles = [
                        { class: 'corner tl', x: 0, y: 0 },
                        { class: 'corner tr', x: rect.width, y: 0 },
                        { class: 'corner bl', x: 0, y: rect.height },
                        { class: 'corner br', x: rect.width, y: rect.height }
                    ];

                    handles.forEach(h => {
                        const handle = document.createElement('div');
                        handle.className = `handle ${h.class}`;
                        handle.style.left = `${h.x}px`;
                        handle.style.top = `${h.y}px`;
                        overlay.appendChild(handle);
                    });

                    const rotateHandle = document.createElement('div');
                    rotateHandle.className = 'handle rotate';
                    overlay.appendChild(rotateHandle);
                }

                canvasContainer.appendChild(overlay);
            });
        }


        // --- 5. Initialisation and Event Handlers ---

        function initialize() {
            setCanvasSize();

            // Load Sierpinski Gasket by default
            const initialScaleFactor = CANVAS_SIZE / 600;
            IFS_PRESETS.sierpinski.forEach(rect => {
                transformationRects.push({
                    x: rect.x * initialScaleFactor,
                    y: rect.y * initialScaleFactor,
                    width: rect.width * initialScaleFactor,
                    height: rect.height * initialScaleFactor,
                    rotation: rect.rotation,
                    p: rect.p,
                    color: rect.color
                });
            });

            renderTransformationsUI();
            setActiveTransform(0);

            // Set initial canvas mode button text
            canvasModeToggleBtn.innerHTML = '<span class="material-icons-round">light_mode</span>Light Canvas';

            // Run one step to show the initial fractal immediately
            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);
            drawPoints(runIFS(numIter), alpha);
        }

        // Mouse/Touch Interaction for Overlays
        canvasContainer.addEventListener('pointerdown', (e) => {
            const target = e.target;
            const overlay = target.closest('.transform-overlay');

            const canvasRect = canvas.getBoundingClientRect();

            if (overlay) {
                e.preventDefault();
                const index = parseInt(overlay.dataset.index);
                setActiveTransform(index);

                activeRect = { ...transformationRects[index], index: index };

                dragStartX = e.clientX - canvasRect.left;
                dragStartY = e.clientY - canvasRect.top;
                initialRectState = { ...activeRect };

                if (target.classList.contains('handle')) {
                    if (target.classList.contains('rotate')) { dragMode = 'rotate'; }
                    else if (target.classList.contains('br')) { dragMode = 'resize-br'; }
                    else if (target.classList.contains('tl')) { dragMode = 'resize-tl'; }
                    else if (target.classList.contains('tr')) { dragMode = 'resize-tr'; }
                    else if (target.classList.contains('bl')) { dragMode = 'resize-bl'; }
                } else {
                    dragMode = 'move';
                }
            } else {
                setActiveTransform(-1);
            }
        });

        canvasContainer.addEventListener('pointermove', (e) => {
            if (activeRectIndex === -1 || !dragMode) return;

            e.preventDefault();
            const canvasRect = canvas.getBoundingClientRect();

            const currentX = e.clientX - canvasRect.left;
            const currentY = e.clientY - canvasRect.top;

            const dx = currentX - dragStartX;
            const dy = currentY - dragStartY;

            const rect = transformationRects[activeRectIndex];

            switch (dragMode) {
                case 'move':
                    rect.x = initialRectState.x + dx;
                    rect.y = initialRectState.y + dy;
                    break;
                case 'resize-br':
                    rect.width = initialRectState.width + dx;
                    rect.height = initialRectState.height + dy;
                    break;
                case 'resize-tl':
                    rect.x = initialRectState.x + dx;
                    rect.y = initialRectState.y + dy;
                    rect.width = initialRectState.width - dx;
                    rect.height = initialRectState.height - dy;
                    break;
                case 'resize-tr':
                    rect.y = initialRectState.y + dy;
                    rect.width = initialRectState.width + dx;
                    rect.height = initialRectState.height - dy;
                    break;
                case 'resize-bl':
                    rect.x = initialRectState.x + dx;
                    rect.width = initialRectState.width - dx;
                    rect.height = initialRectState.height + dy;
                    break;
                case 'rotate':
                    const rectCenterX = initialRectState.x + initialRectState.width / 2;
                    const rectCenterY = initialRectState.y + initialRectState.height / 2;
                    const initialAngle = Math.atan2(dragStartY - rectCenterY, dragStartX - rectCenterX);
                    const currentAngle = Math.atan2(currentY - rectCenterY, currentX - rectCenterX);
                    rect.rotation = initialRectState.rotation + (currentAngle - initialAngle);
                    break;
            }

            rect.width = Math.max(10, rect.width);
            rect.height = Math.max(10, rect.height);
            rect.x = Math.max(0, Math.min(rect.x, CANVAS_SIZE - rect.width));
            rect.y = Math.max(0, Math.min(rect.y, CANVAS_SIZE - rect.height));

            renderTransformationsUI();
        });

        canvasContainer.addEventListener('pointerup', () => {
            dragMode = null;
            renderTransformationsUI();
        });

        // Control Panel Event Listeners
        document.getElementById('addTransform').addEventListener('click', () => {
            stopAutoIterate();
            addTransformUI();
        });

        document.getElementById('iterateBtn').addEventListener('click', () => {
            stopAutoIterate();
            if (transformationRects.length === 0) {
                alert("Please add or load a transformation set.");
                return;
            }
            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);
            drawPoints(runIFS(numIter), alpha);
        });

        document.getElementById('playPauseBtn').addEventListener('click', toggleAutoIterate);
        document.getElementById('canvasModeToggleBtn').addEventListener('click', toggleCanvasTheme);
        document.getElementById('randomBtn').addEventListener('click', () => {
            stopAutoIterate();
            transformationRects = [];
            generateRandomIFS(Math.floor(Math.random() * 4) + 2);
            renderTransformationsUI();
            resetCanvas();
            // This only draws the initial set of points (a single step), it does not start auto-iterate.
            const numIter = parseInt(document.getElementById('numIterations').value);
            const alpha = parseFloat(document.getElementById('alphaValue').value);
            drawPoints(runIFS(numIter), alpha);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            stopAutoIterate();
            resetCanvas(true);
        });


        window.addEventListener('resize', setCanvasSize);

        initialize();
    </script>

</body>

</html>